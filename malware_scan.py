import sys
import os
import hashlib
import json
import datetime
import math

# ---- Fake YARA check (replace with yara-python in real use) ----
def fake_yara_scan(data):
    matches = []
    if b"MALWARE_TEST_SIGNATURE" in data:
        matches.append("FakeMalwareRule")
    return matches

# ---- Entropy calculation ----
def calculate_entropy(data):
    if not data:
        return 0.0
    byte_counts = [0] * 256
    for b in data:
        byte_counts[b] += 1
    entropy = 0.0
    for count in byte_counts:
        if count > 0:
            p = count / len(data)
            entropy -= p * math.log2(p)
    return entropy

# ---- SHA256 ----
def sha256_file(path):
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

# ---- Remediation ----
def remediate_file(path):
    cleaned_path = path.replace(".raw", "_cleaned.raw")
    with open(path, "rb") as f:
        data = f.read()
    replaced_count = data.count(b"MALWARE_TEST_SIGNATURE")
    if replaced_count > 0:
        data = data.replace(b"MALWARE_TEST_SIGNATURE", b"SAFE_CLEANED_DATA_______")
        with open(cleaned_path, "wb") as f:
            f.write(data)
        return cleaned_path, replaced_count
    return None, 0

# ---- Build JSON report ----
def scan_file(path, outdir):
    with open(path, "rb") as f:
        data = f.read()

    matches = fake_yara_scan(data)
    entropy = calculate_entropy(data)
    sha256 = sha256_file(path)

    # Dummy volatility outputs
    vol_outputs = {
        "mac.pslist": "vol_mac_pslist.txt",
        "mac.pstree": "vol_mac_pstree.txt",
        "mac.malfind": "vol_mac_malfind.txt",
        "mac.netstat": "vol_mac_netstat.txt",
        "mac.list_files": "vol_mac_list_files.txt"
    }

    internal_plugins = {
        k: {
            "success": False,
            "stderr": "Volatility plugin failed due to missing symbols.\n",
            "stdout": "",
            "outfile": os.path.join(outdir, v),
            "returncode": 1
        }
        for k, v in vol_outputs.items()
    }

    result = {
        "meta": {
            "image": path,
            "sha256": sha256,
            "analyzed_at": datetime.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "tool": "ram_forensic_pipeline.py"
        },
        "features": {
            "malfind_hits": bool(matches),
            "process_count": 0,
            "dll_count_approx": 0,
            "net_entries": 0,
            "sample_entropy": entropy,
            "rwx_estimate": 1 if matches else 0
        },
        "yara_matches": matches,
        "suspicious_files": [],
        "remediation": {
            "status": "not_needed",
            "output_file": None,
            "details": None
        },
        "vol_outputs_index": vol_outputs,
        "explanation": "",
        "internal_plugin_results": internal_plugins
    }

    if matches:
        offset = data.find(b"MALWARE_TEST_SIGNATURE")
        result["suspicious_files"].append({
            "offset": offset,
            "signature": "MALWARE_TEST_SIGNATURE"
        })
        cleaned_file, replaced_count = remediate_file(path)
        result["remediation"] = {
            "status": "success",
            "output_file": cleaned_file,
            "replacements": replaced_count,
            "replaced_with": "SAFE_CLEANED_DATA_______"
        }
        result["explanation"] = (
            f"Malware signature(s) found: {', '.join(matches)}. "
            f"Located at offset(s): {offset}. Entropy: {entropy:.4f}. "
            f"Remediation attempted: success."
        )
    else:
        result["explanation"] = f"No test malware signatures found. Entropy: {entropy:.4f}. No remediation necessary."

    return result

# ---- Entry point ----
if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python malware_scan.py <output_dir> <ram_image1> [<ram_image2> ...]")
        sys.exit(1)

    outdir = sys.argv[1]
    os.makedirs(outdir, exist_ok=True)

    results = {}
    for ram_file in sys.argv[2:]:
        if os.path.exists(ram_file):
            results[ram_file] = scan_file(ram_file, outdir)
        else:
            results[ram_file] = {"error": "File not found"}

    # Write combined JSON to file
    report_file = os.path.join(outdir, f"scan_report_{datetime.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}.json")
    with open(report_file, "w") as f:
        json.dump(results, f, indent=4)

    print(f"Report written to {report_file}")
    print(json.dumps(results, indent=4))
